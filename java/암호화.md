# 데이터 암호화

데이터 암호화는 크게 단방향 암호화와 양방향 암호화가 존재한다.

단방향 암호화의 경우 해시함수를 이용해서 평문을 해시값으로 변화시켜 암호화한다.

대표적으로 SHA-256, MD5, BCrypt 해시 알고리즘이 있다.

## 해시 함수는 '데이터'가 아니라 '바이트'를 먹는다!

SHA-256 같은 해시 알고리즘은 "안녕"이라는 글자를 이해할 수 없다.

알고리즘이 파라미터로 전달 받는 값은 이진 데이터(Binary Data), 즉 바이트열입니다.

그렇기 때문에 암호화 할 문자열을 바이트 배열로 먼저 변환을 해야하며 이때 어떤 캐릭터셋(Charset)을 선택하느냐에 따라 암호화 결과값(해시값)이 완전 달라집니다.

만약 자바 코드에서 String.getBytes() 처럼 인자 없이 메서드를 호출하면, 시스템의 기본 캐릭터셋을 사용하게 됩니다.

동일한 비밀번호 "password123!"를 넣어도 운영체제 설정이 다르면 DB에 저장된 해시값과 로그인 시 검증하는 해시 값이 불일치하는 상황이 발생할 수 있습니다.

그렇게 때문에 반드시 StandardCharsets.UTF_8처럼 명시적으로 지정해야 합니다.


**단방향 암호화는 해시 함수로 생성한 해시 값이 같다면 두 데이터가 같다고 간주한다.**

---

## 단방향 암호화에 대해서 내가 이해한 내용 적어보기

암호화에 대해서 정리해보면 암호화는 평문을 먼저 바이트 배열로 변경해.

이 이유는 해시 알고리즘은 바이트 배열을 파라미터로 받기 때문이야.

해시 알고리즘은 이렇게 입력받은 바이트 배열을 이용해서 또 다른 해시 바이트 배열을 계산해.

이때 예를 들어 SHA-256의 경우에는 256비트 즉 32바이트 크기의 바이트 배열을 입력값을 기준으로 생성하는거지.

이렇게 생성된 32바이트 배열을 영속화 할때 각 DB별로 표현가능하게 저장하는데.

이때 hex는 16진법을 이용해서 32바이트의 데이터를 64개의 문자로 변환해서 저장하며. 이런 방식을 가장 많이 이용해.

---

### 🛡️ 단방향 암호화(SHA-256) 데이터 흐름도

1. **Input (String):** `"MyPassword123"`
2. **Conversion (Charset):** 문자열을 `UTF-8` 바이트 배열로 변환 (데이터의 원재료 준비)
3. **Hashing (SHA-256):** 알고리즘이 바이트를 섞고 압축하여 **고정된 32바이트** 생성
4. **Encoding (Hex):** 32바이트를 읽기 쉬운 **64글자 문자열(16진수)**로 변환
5. **Storage (DB):** `CHAR(64)` 타입의 컬럼에 안전하게 저장

---

### Salt

암호화를 **더 안전하게** 만들기 위해 반드시 추가하는 **Salt(솔트)**

* **문제점:** "1234"를 SHA-256으로 돌리면 전 세계 어디서나 똑같은 64글자가 나오며 해커들은 이미 이 표(Rainbow Table)를 가지고 있어서 금방 비밀번호를 알아낸다.
* **해결책 (Salt):** 사용자가 입력한 비밀번호 뒤에 아주 긴 랜덤 문자열(Salt)을 붙여서 바이트 배열로 만든다.
* `"1234" + "random_salt_77"` → **해시**

* **결과:** 이렇게 하면 같은 "1234"라도 사용자마다 저장되는 해시값이 완전히 달라져서 훨씬 안전해진다...

---

### Hex vs Base64 비교

| 구분 | Hex (16진수) | Base64 (64진수) |
| --- | --- | --- |
| **한 글자당 비트** | 4비트 | 6비트 |
| **사용 문자** | 0-9, a-f (16개) | A-Z, a-z, 0-9, +, / (64개) |
| **SHA-256 길이** | 64글자 | 약 44글자 |
| **특징** | 가독성이 좋고 표준적임 | 저장 공간을 약 33% 절약함 |

---

## base 64 궁금증

### 왜 64진법인가?

우리가 읽을 수 있는 안전한 문자(대문자 A-Z, 소문자 a-z, 숫자 0-9, 기호 +, /)를 모두 합치면 딱 **64개**가 돼.

*  이므로, **문자 하나가 6비트**를 담당할 수 있는 거지.

### 왜 44글자가 되는 걸까? (계산의 마법)

SHA-256의 결과물인 **256비트**를 기준으로 계산해 보자.

1. **비트 단위 계산:**
2. **올림 처리:** 비트는 중간에 잘릴 수 없으니 43개가 필요해.
3. **패딩(Padding):** Base64는 보통 4글자 단위(24비트 묶음)로 맞춰야 하는 규칙이 있어서, 빈자리를 `=` 기호로 채워.
4. **최종 결과:** 그래서 약 **44글자** 내외가 되는 거야.

> **Hex(16진수):** 256비트 / 4비트 = **64글자** > **Base64(64진수):** 256비트 / 6비트  **44글자**
