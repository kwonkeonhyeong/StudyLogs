# ArrayList & LinkedList 성능 비교

---

## 직접 구현한 ArrayList & LinkedList 성능 비교

### ==MyArrayList 추가==
- 앞에 추가 - 크기: 50000, 계산 시간: 870ms
- 평균 추가 - 크기: 50000, 계산 시간: 470ms
- 뒤에 추가 - 크기: 50000, 계산 시간: 1ms


### ==MyArrayList 조회==
- index: 0, 반복: 10000, 계산 시간: 0ms
- index: 25000, 반복: 10000, 계산 시간: 0ms
- index: 49999, 반복: 10000, 계산 시간: 1ms


### ==MyArrayList 검색==
- findValue: 0, 반복: 10000, 계산 시간: 0ms
- findValue: 25000, 반복: 10000, 계산 시간: 91ms
- findValue: 49999, 반복: 10000, 계산 시간: 168ms


### ==MyLinkedList 추가==
- 앞에 추가 - 크기: 50000, 계산 시간: 2ms
- 평균 추가 - 크기: 50000, 계산 시간: 1061ms
- 뒤에 추가 - 크기: 50000, 계산 시간: 1990ms


### ==MyLinkedList 조회==
- index: 0, 반복: 10000, 계산 시간: 1ms
- index: 25000, 반복: 10000, 계산 시간: 388ms
- index: 49999, 반복: 10000, 계산 시간: 734ms


### ==MyLinkedList 검색==
- findValue: 0, 반복: 10000, 계산 시간: 0ms
- findValue: 25000, 반복: 10000, 계산 시간: 446ms
- findValue: 49999, 반복: 10000, 계산 시간: 915ms

---

## Java.util ArrayList & LinkedList 성능 비교

### ==ArrayList 추가==
- 앞에 추가 - 크기: 50000, 계산 시간: 88ms
- 평균 추가 - 크기: 50000, 계산 시간: 37ms
- 뒤에 추가 - 크기: 50000, 계산 시간: 2ms


### ==ArrayList 조회==
- index: 0, 반복: 10000, 계산 시간: 0ms
- index: 25000, 반복: 10000, 계산 시간: 0ms
- index: 49999, 반복: 10000, 계산 시간: 1ms


### ==ArrayList 검색==
- findValue: 0, 반복: 10000, 계산 시간: 0ms
- findValue: 25000, 반복: 10000, 계산 시간: 90ms
- findValue: 49999, 반복: 10000, 계산 시간: 163ms


### ==LinkedList 추가==
- 앞에 추가 - 크기: 50000, 계산 시간: 2ms
- 평균 추가 - 크기: 50000, 계산 시간: 963ms
- 뒤에 추가 - 크기: 50000, 계산 시간: 2ms


### ==LinkedList 조회==
- index: 0, 반복: 10000, 계산 시간: 0ms
- index: 25000, 반복: 10000, 계산 시간: 423ms
- index: 49999, 반복: 10000, 계산 시간: 0ms


### ==LinkedList 검색==
- findValue: 0, 반복: 10000, 계산 시간: 0ms
- findValue: 25000, 반복: 10000, 계산 시간: 460ms
- findValue: 49999, 반복: 10000, 계산 시간: 873ms

---

## 시간 복잡도와 실제 성능

이론적으로 MyLinkedList의 평균 추가(중간 삽입) 연산은 MyArrayList보다 빠를 수 있다.

그러나 실제 성능은 요소의 순차적 접근 속도, 메모리 할당 및 해제 비용, CPU 캐시 활용도 등 다양한 요소에 의해 영향을 받는다.

MyArrayList의 요소들이 **메모리 상에서 연속적으로 위치하여 CPU 캐시 효율이 좋고, 메모리 접근 속도가 빠르다.**

MyLinkedList는 각 **요소가 별도의 객체로 존재하고 다음 요소의 참조를 저장하기 때문에 CPU 캐시 효율이 떨어지고, 메모리 접근 속도가 상대적으로 느릴 수 있다.**

MyArrayList의 경우 capacity를 넘어서면 배열을 다시 만들고 복사하는 과정이 추가된다. 하지만 한번에 2배씩 늘어나기 때문에 이 과정은 가끔 일어나며, 전제 성능에 큰 영향을 주지 않는다.

결론적으로, MyLinkedList가 평균 추가(중간 삽입)에 있어 이론적으로 더 효율적일 수 있지만, 현재 컴퓨터 시스템의 메모리 접근 패턴, CPU 캐시 최적화 등을 고려할 때 

MyArrayList가 실제 사용 환경에서 더 나은 성능을 보여주는 경우가 많다.

---

## 알아가는 점

이론적으로 데이터를 추가할 때는 LinkedList를 쓰는게 빠르다! 라고 말하는 경운데, 실제 구현 및 테스트를 해보면 ArrayList가 훨씬 빠르다.

메모리 연속 구조 등에 따른 문제들에 따라서 대부분의 경우 배열 리스트가 훨씬 유리하다.

맨 앞에 데이터를 넣는 경우가 아니라면 배열 리스트가 훨씬 빠르다~!
