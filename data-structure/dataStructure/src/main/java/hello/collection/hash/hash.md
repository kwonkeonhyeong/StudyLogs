## 해시 알고리즘

해시 알고리즘을 사용하면 데이터를 찾는 검색 성능을 평균 O(1)로 비약적으로 끌어올릴 수 있다.


## index 사용?

배열은 인덱스의 위치를 사용해서 데이터를 찾을 때 O(1)로 매우 빠른 특징을 가지고 있다.

반면에 데이터를 검색할 때는 배열에 들어있는 데이터 하나하나를 모두 비교해야 하므로 인덱스를 활용할 수 없다.

그런데 만약에 데이터를 검색할 때도 인덱스를 활용해서 데이터를 한 번에 찾을 수 있다면??

이렇게 하면 O(n) -> O(1)로 바꾸어서 성능을 획기적으로 끌어올릴 수 있다.

=> 데이터의 값 자체를 배열의 인덱스와 맞추어 저장하며 어떨까? 데이터의 값 자체를 배열의 인덱스로 사용하는 것이다!

데이터의 값을 인덱스로 사용하는 방법은 매우 빠른 성능을 보장하지만, 입력 값의 범위가 조금만 커져도 메모리 낭비가 너무 심하다.


## 나머지 연산?

공간도 정략하면서, 넓은 범위의 값을 사용할 수 있는 방법은 나머지 연산을 사용하는 것이다. 

저장할 수 있는 배열의 크기(capacity)를 10이라고 가정하자. 그 크기에 맞추어 나머지 연산을 사용하면 된다.


**해시 인덱스**

이렇게 배열의 인덱스로 사용할 수 있도록 원래의 값을 계산한 인덱스를 해시 인덱스(hashIndex)라 한다.

14의 해시 인덱스는 4, 99의 해시 인덱스는 9이다.

- 저장할 값에 나머지 연산자를 사용하여 해시 인덱스를 구한다.
- 해시 인덱스를 배열의 인덱스로 사용해서 데이터를 저장한다.
  - inputArray[hashIndex] = inputValue;
- 배열의 인덱스를 사용하기 때문에 하나의 값을 저장하는데 O(1)로 빠른 성능을 제공한다.

**해시 인덱스와 데이터 조회**

- 조회할 값에 나머지 연산자를 사용해서 해시 인덱스를 구한다.

- 해시 인덱스를 배열의 인덱스로 사용해서 데이터를 조회한다.
    - int value = inputArray[hashIndex];
- 배열의 인덱스를 사용하기 때문에 하나의 값을 찾는데 O(1)로 빠른 성능을 제공한다.

---

## 한계

저장할 위치가 충돌할 수 있다는 한계가 있다. => 해시 충돌

---

## 해시 충돌

99, 9의 두 값은 10으로 나누면 9가 된다. 따라서 다른 값을 입력했지만 같은 해시 코드가 나오게 되는데 이것을 해시 충돌이라 한다.

## 해시 충돌 해결

해시 충돌을 인정한다.

해시 충돌은 낮은 확률로 일어날 수 있다고 가정하는 것이다.

해결 방안은 바로 해시 충돌리 일어났을 때 단순하게 같은 해시 인덱스의 값을 같은 인덱스에 함께 저장해버리는 것이다.

물론 여러 데이터를 배열의 하나의 공간에 함께 저장할 수는 없다. 

대신에 배열 안에 배열을 만들면 된다. 물론 배열 안에 리스트 같은 다른 자료구조를 사용해도 된다.

## 해시 충돌과 조회

해시 충돌이 난 경우 내부의 데이터를 하나씩 바교해보면 원하는 결과를 찾을 수 있다.

## 정리

해시 인덱스를 사용하는 방식은 최악의 경우 O(n)의 성능을 보인다.

하지만 확률적으로 보면 어느 정도 넓게 퍼지기 때문에 평균으로 보면 O(1)의 성능을 제공한다.

해시 충돌이 가끔 발생해도 내부에서 값을 몇 번만 비교하는 수준이기 때문에 대부분의 값을 매우 빠르게 찾을 수 있다.

데이터의 수가 배열의 크기를 75% 넘지 안흥면 해시 인덱스는 자주 충돌하지 않는다. 반대로 75%를 넘으면 자주 충돌한다. 

배열의 크기를 크게 만들면 해시 충돌은 줄어서 성능은 좋아지지만, 많은 메모리가 낭비된다. 

반대로 배열의 크기를 너무 작게 만들면 해시가 자주 충돌해서 성능이 나빠진다.

상황에 따라 다르겠지만 보통 75%를 적절한 크기로 보고 기준으로 잡는 것이 효과적이다.

---

## 성능

데이터 저장
- 평균 : O(1)
- 최악 : O(n)

데이터 조회
- 평균 : O(1)
- 최악 : O(n)
