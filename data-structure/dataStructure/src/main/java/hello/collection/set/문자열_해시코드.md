# 문자열 해시코드

해시 인덱스를 구할 때 숫자를 기반으로 구했다. 해시 인덱스는 배열의 인덱스로 사용해야 하므로 0,1,2 같은 숫자(양의 정수)만 사용할 수 있다.
따라서 문자를 사용할 수 없다.

문자 데이터를 기반으로 숫자 해시 인덱스를 어떻게 구해야 할까?

컴퓨터는 문자를 직접 이해하지는 못한다. 대신에 각 문자에 고유한 숫자를 할당해서 인식한다. 

모든 문자는 본인만의 숫자로 표현할 수 있다.

가장 단순하게 char 형을 int 형으로 캐스팅하면 문자의 고유한 숫자를 확인할 수 있다.

그리고 "AB"와 같은 연속된 문자는 각각의 문자를 더하는 방식으로 숫자로 표현하면 된다.

---

## 용어 정리

**해시 함수 (Hash Function)**

- 해시 함수는 임의의 길이의 데이터를 입력으로 받아, 고정된 길이의 해시값(해시 코드)을 출력하는 함수이다.
  - 여기서 의미하는 고정된 길이는 저장 공간의 크기를 뜻한다. 예를 들어서 int 형 1, 100은 둘 다 4 byte를 차지하는 고정된 길이를 뜻한다.
- 같은 데이터를 입력하면 항상 같은 해시 코드가 출력된다.
- 다른 데이터를 입력해도 같은 해시 코드가 출력될 수 있다. 이것을 해시 충돌이라 한다.


**해시 코드(Hash Code)**

- 해시 코드는 데이터를 대표하는 값을 뜻한다. 보통 해시 함수를 통해 만들어진다. 


**해시 인덱스(Hash Index)**

- 해시 인덱스는 데이터의 저장 위치를 결정하는데, 주로 해시 코드를 사용해서 만든다.
- 보통 해시 코드의 결과에 배열의 크기를 나누어 구한다.


요약하면, 해시 코드는 데이터를 대표하는 값, 해시 함수는 이러한 해시 코드를 행성하는 함수, 그리고 해시 인덱스는 해시 코드를 사용해서 데이터의 저장 위치를 결정하는 값을 뜻한다.


문자 데이터를 사용할 때도, 해시 함수를 사용해서 정수 기반의 해시 코드로 변환한 덕분에, 해시 인덱스를 사용할 수 있게 되었다.

따라서 문자의 경우레도 해시 인덱스를 통해 빠르게 저장하고 조회할 수 있다.

여기서 핵심은 해시 코드이다.

세상의 어떤 객체든지 정수로 만든 해시 코드만 정의할 수 있다면 해시 인덱스를 사용할 수 있다. 

그렇다면 문자 뿐만 아니라 내가 직접 만든 Member, User와 같은 객체는 어떻게 해시 코드를 정의할 수 있을까?


## 자바의 hashCode()

해시 인덱스를 사용하는 해시 자료구조는 데이터 추가, 검색, 삭제의 성능이 O(1)로 매우 빠르다.

따라서 많은 곳에서 자주 사용된다.

자바에는 int, Integer 뿐만 아니라 char, String, Double, Boolean 등 수 많은 타입이 있다.

뿐만 아니라 개발자가 직접 정의한 Member, User와 같은 사용자 정의 타입도 있다.

이 모든 타입을 해시 자료 구조에 저장하려면 모든 객체가 숫자 해시 코드를 제공할 수 있어야 한다.


## Object.hashCode()

자바는 모든 객체가 자신만의 해시 코드를 표현할 수 있는 기능을 제공한다. 

이 메서드를 그대로 사용하기 보다는 보통 재정의(오버라이딩)해서 사용한다.

이 메서드의 기본 구현은 객체의 참조값을 기반으로 해시 코드를 생성한다.

쉽게 이야기해서 객체의 인스턴스가 다르면 해시 코드도 다르다.


## Object의 해시 코드 비교

- Object가 기본으로 제공하는 hashCode()는 객체의 참조값을 해시 코드로 사용한다. 따라서 각각의 인스턴스마다 서로 다른 값을 반환한다.
- 그 결과 obj1, obj2는 서로 다른 해시 코드를 반환한다.


## 자바의 기본 클래스의 해시 코드

- Integer, String 같은 자바의 기본 클래스들은 대부분 내부 값을 기반으로 해시 코드를 구할 수 있도록 hashCode() 메서드를 재정의해 두었다.
- 따라서 데이터의 값이 같으면 같은 해시 코드를 반환한다.
- 해시 코드의 경우 정수를 반환하기 때문에 마이너스 값이 나올 수 있다.


## 동일성과 동등성 복습

Object는 동등성 비교를 위한 equals() 메서드를 제공한다.

- 동일성 (identity) : == 연산자를 사용해서 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인
- 동등성 (equality) : equals() 메서드를 사용하여 두 객체가 논리적으로 동등한지 확인

동일성은 물리적으로 같은 메모리에 있는 객체인지 참조값을 확인하는 것이고, 동등성은 논리적으로 같은지 확인하는 것이다.

동일성은 자바 머신 기준이고 메모리의 참조가 기준으로 물리적이다. 등등성을 보통 사람이 생각하는 논리적인 것에 기준을 맞춘다. 따라서 논리적이다.


## equals, hashCode의 중요성

해시 자료 구조를 사용하려면 hashCode()도 중요하지만, 해시 인덱스가 충돌할 경우에 대비해서 equals()도 반드시 재정의해야 한다.

해시 인덱스가 충돌할 경우 같은 해시 인덱스에 있는 데이터들을 하나하나 비교해서 찾아야한다. 이때 equals()를 사용해서 비교한다.

해시 인덱스가 같아도 실제 저장된 데이터는 다를 수 있다. 따라서 특정 인덱스에 데이터가 하나만 있어도 equals()로 찾는 데이터가 맞는지 검증해야 한다.

---

## 해시 함수는 해시 코드가 최대한 충돌하지 않도록 설계

다른 데이터를 입력해도 같은 해시 코드가 출력될 수 있다. 이것을 해시 충돌이라 한다.

- "BC" => B(66) + C(67) = 133
- "AB" => A(65) + D(68) = 133

해시 함수로 해시 코드를 만들 때 단순히 문자를 더하기만 해서는 해시가 충돌할 가능성이 높다.

해시가 충돌하면 결과적으로 같은 해시 인덱스에 보관된다. 따라서 성능이 나빠진다.

자바의 해시 함수는 이런 문제를 해결하기 위해 문자의 숫자를 단순히 더하기만 하는 것이 아니라 내부에서 복잡한 추가 연산을 수행한다.

복잡한 추가 연산으로 다양한 범위의 해시 코드가 만들어지므로 해시가 충돌할 가능성이 낮아지고, 결과적으로 해시 자료 구조를 사용할 때 성능이 개선된다.

좋은 해시 함수는 해시 코드가 한 곳에 뭉치지 않고 균일하게 분포하는 것이 좋다.

그래야 해시 인덱스도 골고루 분호되어서 해시 자료 구조의 성능을 최적화할 수 있다.

히언 해시 함수를 직접 구현하는 것은 쉽지 않다. 자바가 제공하는 해시 함수들을 사용하면 이런 부분을 걱정하지 않고 최적화 된 해시 코드를 구할 수 있다.

하지만 자바가 제공하는 해시 함수를 사용해도 같은 해시 코드가 생성되어서 해시 코드가 충돌하는 경우도 간혹 존재한다.

이 경우 같은 해시 코드를 가지기 때문에 해시 인덱스도 같게 된다. 하지만 equals()를 사용해서 다시 비교하기 때문에 해시 코드가 충돌하더라도 문제가 되지 않는다.

그리고 매우 낮은 확률로 충돌하기 때문에 성능에 대한 부분도 크게 걱정하지 않아도 된다.
