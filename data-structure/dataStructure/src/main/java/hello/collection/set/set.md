# set

유일한 요소들의 컬렉션

## 특징

유일성 : set에는 중복된 요소가 존재하지 않는다. set에 요소를 추가할 때, 이미 존재하는 요소면 무시된다.

순서 미보장 : 대부분의 set 구현에서는 요소들의 순서를 보장하지 않는다. 즉, 요소를 출력할 때 입력 순서와 다를 수 있다.

빠른 검색 : set은 요소의 유무를 빠르게 확인할 수 있도록 최적화되어 있다. 이는 데이터의 중복을 방지하고 빠른 조회를 가능하게 한다.

용도 : 중복을 허용하지 않고, 요소의 유무만 중요한 경우에 사용된다.


## 직접 구현한 set의 성능

add()로 데이터를 추가할 때에는 set에 중복 데이터가 있는지 전체 데이터를 항상 확인해야 한다.

따라서 O(n)으로 입력 성능이 나쁘다.

중복 데이터 검색 O(n) + 데이터 입력 O(1) => O(n)

contains()로 데이터를 찾을 때는 배열에 있는 모든 데이터를 찾고 비교해야 하므로 평균 O(n)이 걸린다.

중복 데이터 검색에서 소요되는 시간을 어떻게 줄일 수 있을까??

## 자바가 제공하는 Set - HashSet, LinkedHashSet

Set은 수학적 집합 개념을 구현한 것!

순서를 보장하지 않으며, 특정 요소가 집합에 있는지 여부를 확인하는 데 최적화되어 있다.


### 1. HashSet

구현 -> 해시 자료 구조를 사용해서 요소를 저장한다.

순서 -> 요소들은 특정한 순서 없이 저장된다. 즉, 요소를 추가한 순서를 보장하지 않는다.

시간 복잡도 -> HashSet의 주요 연산 (추가, 삭제, 검색)은 평균적으로 O(1) 시간 복잡도를 가진다.

용도 -> 데이터의 유일성만 중요하고, 순서가 중요하지 않은 경우 적합하다.


### 2. LinkedHashSet

구현 -> LinkedHashSet은 HashSet에 연결 리스트를 추가해서 요소들의 순서를 유지한다.

순서 -> 요소들은 추가된 순서대로 유지된다. 즉, 순서대로 조회 시 요소들이 추가된 순서대로 반환된다.

시간 복잡도 -> LinkedHashSet도 HashSet과 마찬가지로 주요 연산에 대해 평균 O(1) 시간 복잡도를 가진다.

용도 -> 데이터의 유일성과 함께 삽입 순서를 유지해야 할 때 적합하다.

참고 -> 연결 링크를 유지해야 하기 때문에 HashSet보다는 조금 더 무겁다


### 3. TreeSet

구현 -> TreeSet은 이진 탐색 트리를 개선한 레드-블랙 트리를 내부에서 사용한다.

순서 -> 요소들은 정렬된 순서로 저장된다. 순서의 기준은 비교자로 변경할 수 있다.

시간 복잡도 -> 주요 연산들은 O(log n)의 시간 복잡도를 가진다. 따라서 HashSet 보다는 느리다.

용도 : 데이터들을 정렬된 순서로 유지하면서 집합의 특정을 유지해야 할 때 사용한다.

예를 들어, 범위 검색이나 정렬된 데이터가 필요한 경우에 유용하다. 참고로 입력된 순서가 아니라 데이터 값의 순서이다.

예를 들어 3,1,2를 순서대로 입력해도 1,2,3 순서로 출력된다.


### 트리 구조

트리는 부모 노드와 자식 노드로 구성된다. 

자식이 2개까지 올 수 있는 트리를 이진 트리라 한다.

여기에 노드의 왼쪽 자손은 더 작은 값을 가지고, 오른쪽 자손은 더 큰 값을 가지는 것을 이진 탐색 트리라 한다.

TreeSet은 이진 탐색 트리를 개선한 레드-블랙 트리를 사용한다.

이진 탐색 트리는 데이터를 입력하는 시점에 정렬해서 보관한다는 점이다. 그리고 작은 값은 왼쪽에 큰 값은 오른쪽에 저장하면 된다.

이진 탐색 트리의 핵심은 한번에 절반을 날린 다는 점이다. O(log n)

데이터의 크기가 늘어나도 늘어난 만큼 한 번의 계산에 절반을 날려버리기 때문에, O(n)과 비교해서 데이터의 크기가 클 수록 효과적이다.

이진 탐색 트리의 검색, 삽입, 삭제의 평균 성능은 O(log n)이다. 

하지만 트리의 균형이 맞지 않으면 최악의 경우 O(n)의 성능이 나온다.

이런 문제를 해결하기 위한 다양한 해결 방안이 있는데, 트리의 균형이 너무 깨진 경우 동적으로 균형을 다시 맞추는 것이다.

AVL 트리, 레드-블랙 트리 같은 균형을 맞추는 다양한 알고리즘이 존재한다.

자바의 TreeSet은 레드-블랙 트리를 사용해서 균형을 지속해서 유지한다. 따라서 최악의 경우에도 O(log n)의 성능을 제공한다. 

이진 탐색 트리의 핵심은 입력 순서가 아니라, 데이터의 값을 기준으로 정렬해서 보관한다는 점이다.

따라서 정렬된 순서로 데이터를 차례로 조회할 수 있다. (순회 할 수 있다.)

데이터를 차례로 순회하려면 중위 순회라는 방법을 사용하면 된다.

왼쪽 서브트리를 방문한 다음, 현재 노드를 처리하고, 마지막으로 오른쪽 서브트리를 방문한다. 

이 방식은 이진 탐색 트리의 특성상, 노드를 오름차순으로 방문한다.

### TreeSet의 정렬 기준

TreeSet을 사용할 때 데이터를 정렬하려면 크다, 작다라는 기준이 필요하다. 

1,2,3이나 "A", "B", "C" 같은 기본 데이터는 크다 작다라는 기준이 명확하기 때문에 정렬할 수 있다. 

하지만 우리가 직접 만든 Member와 같은 객체는 크다 작다는 기준을 어떻게 알 수 있을까? 

이런 기준을 제공하려면 Comparable, Comparator 인터페이스를 구현해야 한다.

---

### 자바 HashSet과 최적화 

- 자바의 HashSet은 우리가 직접 구현한 내용과 거의 같지만 다음과 같은 최적화를 추가로 진행한다. 

**최적화**

해시 기반 자료 구조를 사용하는 경우 통계적으로 입력한 데이터의 수가 배열의 크기를 75% 정도 넘어가면 해시 인덱스가 자주 충돌한다. 

따라서 75%가 넘어가면 성능이 떨어지기 시작한다. 

해시 충돌로 같은 해시 인덱스에 들어간 데이터를 검색하려면 모두 탐색해야 한다. 

따라서 성능이 O(n)으로 좋지 않다. 

하지만 데이터가 동적으로 계속 추가되기 때문에 적절한 배열의 크기를 정하는 것은 어렵다. 

자바의 HashSet은 데이터의 양이 배열 크기의 75%가 넘어가면 배열의 크기를 2배로 늘리고 2배 늘어난 크기를 기준으로 모든 요소에 해시 인덱스를 다시 적용한다. 

해시 인덱스를 다시 적용하는 시간이 걸리지만, 결과적으로 해시 충돌이 줄어든다. 

자바의 HashSet의 기본 크기는 16이다. 


